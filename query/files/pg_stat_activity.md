### Работа с pg_stat_activity

PostgreSQL RDBMS имеет очень информативные встроенные инструменты для отслеживания состояния базы данных. Одним из таких инструментов является pg_stat_activity.
Это системное представление, позволяющее отслеживать процессы баз данных в режиме реального времени. Это представление сравнимо с системной командой top, 
это одно из первых мест, с которых администратор базы данных может начать расследование в случае возникновения какой-либо проблемы. 
Далее будет приведено несколько полезных примеров, как это представление можно использовать для обнаружения аномальной активности. 
Для начала нам нужен только клиент postgresql, например psql.

Для начала можно использовать самый простой запрос:

      SELECT * FROM pg_stat_activity;

Не важно, к какой базе данных вы подключены, pg_stat_activity является общей для всех баз данных.

pg_stat_activity показывает одну строку для каждого соединения с базой данных. Для каждого соединения существует отдельный процесс UNIX. Для одного соединения есть несколько атрибутов:

***pid*** - идентификатор процесса, который обрабатывает соединение. В терминологии PostgreSQL этот процесс называется backend или worker.

***datid, datname***   - идентификатор и имя базы данных, к которой подключается клиент.

***useysid, usename*** - идентификатор и имя, которое использовалось для подключения.

***client_addr, client_port, client_hostname*** - сетевые настройки клиента, сетевой адрес, порт и имя хоста.

***application_name*** - произвольное имя, которое может быть указано, когда клиент подключается или переменная сеанса.

***backend_start, xact_start, query_start, state_change*** - отметки времени, которые указывают, когда был запущен процесс (backend), транзакция или запрос внутри транзакции, и когда в последний раз состояние процесса было изменено.

***state, waiting*** - состояние процесса и флаг, который указывает, ожидает ли процесс другого процесса.

***query*** - текст запроса, который в данный момент выполняется работником или был недавно выполнен в связи с этим.

Поскольку каждая строка описывает одно соединение, мы можем легко узнать, сколько клиентских соединений установлено с базой данных.

            SELECT count(*) AS total_conns FROM pg_stat_activity;
            total_conns 
            -------------
            61

Затем мы можем использовать предложение WHERE и добавить параметры фильтра. Например, мы можем увидеть, сколько соединений установлено с хоста с адресом 10.0.20.26.

            SELECT count(*) FROM pg_stat_activity WHERE client_addr = '10.0.20.26';
            count 
            -------
            10

Конечно, мы можем использовать разные условия и фильтровать другие поля, включая и комбинируя их с помощью AND и OR. Очень важными атрибутами являются время начала транзакции и запроса. Используя текущее время, мы можем рассчитать продолжительность транзакций и запросов. Это очень полезно для обнаружения длинных транзакций.

            SELECT
            client_addr, usename, datname,
            clock_timestamp() - xact_start AS xact_age,
            clock_timestamp() - query_start AS query_age,
            state, query
            FROM pg_stat_activity 
            ORDER BY coalesce(xact_start, query_start);
            
            -[ RECORD 1 ]-------------------------------------------------------
            client_addr | 10.0.20.26
            usename     | james
            datname     | sales_db
            xact_age    | 
            query_age   | 12 days 05:52:09.181345
            state       | idle
            query       | <query text>

