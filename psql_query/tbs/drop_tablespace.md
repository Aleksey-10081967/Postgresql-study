#### Удаление табличного тространства с объектами

DROP TABLESPACE new_ts; -  выполняет удаление табличного пространства если в нем нет ничего
CASCADE - не работает т.к. в табличном пространстве могут быть объекты из разных БД

Наши действия:

1. Находим OID табличного пространства которое хотим удалить:
    
    SELECT OID FROM pg_tablespace WHERE spcname = '<name_ts>';
    
2. Запишем OID_TS в переменную tsoid;

    SELECT OID AS tsoid FROM pg_tablespace WHERE spcname = '<name_ts>' \gset ;
    
3. Получаем список баз в которых есть объекты удаляемого пространства:

    SELECT datname FROM pg_database WHERE OID IN (SELECT pg_tablespace_databases(:tsoid));
    
4. После этого подключаемся каждой БД и что-то делаем с объектами находящихся в удаляемом табличном пространстве.

4.1. Ищем объекты принадлежание удаляемому табличному пр-ву в конкретной БД
    
    \с <name_db>;
    SELECT relnamespace::regnamespace, relname, relkind FROM pg_class WHERE reltablespace = :tsoid;
    
ВНИМАНИЕ: В Postgres табличное пространство по умолчанию обозначается -> 0

4.2. \c <name_db>;

    SELECT count(*) FROM pg_class WHERE reltablespace=0;
    
    Вывод - 313 - это системные объекты
    
Мы их удалить не можем, поэтому перемещаем в другое табличное пространство.

Для этого меняем у БД табличное пространство по умолчанию:

    \c postgres
    ALTER DATABASE appdb SET TABLESPACE pg_default;
   
После чего системный каталог уедет в табличное пр-во по умолчанию.

5. Может удалять табличное пр-во
Системный каталог размещается в табличном пространстве Бд по умолчанию и перезжает в другое табличное пространство полностью. 
При этом из БД должны быть выгнаны все пользователи.
Для запрещения полключения временно можно устновить параметр CONNECTION LIMIT 0, выгнать пользователей, перевести системный каталог и упрать параметр CONNECTION LIMIT

    ALTER DATABASE <name_db> CONNECTION LIMIT 0 - установка ограничения на подключение

    ALTER DATABASE <name_db> CONNECTION LIMIT -1 - снятие ограничений на подключения
